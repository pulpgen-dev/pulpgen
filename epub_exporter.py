# epub_exporter.py
# -*- coding: utf-8 -*-
import xml.etree.ElementTree as ET
import uuid
import html
from pathlib import Path
from datetime import datetime
import re
import unicodedata
from rich.markup import escape as escape_markup

# --- Core Dependency ---
try:
    from ebooklib import epub # The core library
except ImportError:
    print("Error: The 'ebooklib' library is required for EPUB export.")
    print("Please install it using: pip install EbookLib")
    # You might want to raise an exception or handle this more gracefully
    # depending on how pulpgen.py handles missing optional dependencies.
    # For now, we'll let subsequent code fail if epub is not available.
    epub = None # Set to None to indicate it's missing

from rich.console import Console
from rich.panel import Panel

# --- Rich Console Setup ---
# Use a shared console instance if available, or create a new one
# This assumes pulpgen might pass a console, otherwise uses a local one.
# For standalone use or simplicity, a local console is fine.
console = Console()

# --- Helper Functions (Copied/Adapted from pulpgen.py / generate_epub.py) ---

def slugify(value, allow_unicode=False):
    """
    Convert to ASCII if 'allow_unicode' is False. Convert spaces or repeated
    dashes to single dashes. Remove characters that aren't alphanumerics,
    underscores, or hyphens. Convert to lowercase. Also strip leading and
    trailing whitespace, dashes, and underscores.
    """
    value = str(value)
    if allow_unicode:
        value = unicodedata.normalize("NFKC", value)
    else:
        value = (
            unicodedata.normalize("NFKD", value)
            .encode("ascii", "ignore")
            .decode("ascii")
        )
    value = re.sub(r"[^\w\s-]", "", value.lower())
    value = re.sub(r"[-\s]+", "-", value).strip("-_")
    # Ensure not empty, limit length
    slug = value[:50] or "untitled"
    return slug

def _get_sorted_chapters(book_root):
    """Helper to get chapters sorted numerically by ID."""
    if book_root is None:
        return []
    chapters_raw = book_root.findall(".//chapter")
    # Handle chapters that might be missing 'id' or have non-integer IDs during sorting
    def get_sort_key(chap):
        chap_id_str = chap.get("id", "0")
        try:
            # Attempt to convert to integer for robust sorting
            return int(chap_id_str)
        except ValueError:
             # If ID is not an integer, use a large number to sort it later
             # or use string sorting if preferred (but numerical is usually better for chapters)
             # Using float('inf') ensures non-numeric IDs go last
             return float('inf')
    try:
        return sorted(chapters_raw, key=get_sort_key)
    except Exception as e:
        console.print(f"[yellow]Warning: Could not sort chapters numerically ({e}). Using XML order.[/yellow]")
        return chapters_raw # Fallback to original order if sorting fails badly


def format_chapter_xhtml(chapter_element, chapter_title, css_filename="style.css"):
    """Formats the content of a chapter XML element into a valid XHTML string (as bytes)."""
    paragraphs_html = []
    content_element = chapter_element.find("content")
    if content_element is not None:
        for para in content_element.findall(".//paragraph"):
            para_text = para.text if para.text else ""
            # Escape HTML special characters and replace explicit newlines with <br />
            # Strip leading/trailing whitespace *after* potential newline replacement if needed,
            # but usually preserving internal spacing is desired.
            escaped_text = html.escape(para_text.strip()).replace("\n", "<br />\n    ")

            if not escaped_text:
                # Use non-breaking space for empty paragraphs to ensure tags render correctly
                paragraphs_html.append("<p> </p>") #   is nbsp
            else:
                paragraphs_html.append(f"<p>{escaped_text}</p>")

    if not paragraphs_html:
         paragraphs_html.append("<p><i>[Chapter content is empty or missing]</i></p>")

    # Basic XHTML structure for a chapter file (EPUB 3)
    xhtml_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en">
<head>
    <meta charset="UTF-8" />
    <title>{html.escape(chapter_title)}</title>
    <link rel="stylesheet" type="text/css" href="{css_filename}" />
</head>
<body>
    <h1 class="chapter-title">{html.escape(chapter_title)}</h1>
    {''.join(paragraphs_html)}
</body>
</html>"""
    return xhtml_content.encode('utf-8') # EbookLib expects bytes

# --- Basic CSS for the EPUB ---
DEFAULT_CSS = """
/* Default styles for EPUB generated by PulpGen */
body {
    font-family: Georgia, serif;
    line-height: 1.6;
    margin: 1em 1.5em; /* Add some horizontal margin */
    text-align: justify;
    widows: 2; /* Minimum lines at top of page */
    orphans: 2; /* Minimum lines at bottom of page */
    -webkit-hyphens: auto; /* Enable hyphenation */
    -moz-hyphens: auto;
    -ms-hyphens: auto;
    hyphens: auto;
}

h1.chapter-title {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 1.8em;
    font-weight: bold;
    text-align: center;
    margin-top: 2.5em;
    margin-bottom: 1.5em;
    line-height: 1.3;
    page-break-before: always; /* Start each chapter on a new page */
    -webkit-hyphens: none; /* Avoid hyphenating titles */
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

p {
    text-indent: 1.5em;
    margin-top: 0;
    margin-bottom: 0.2em; /* Tighter paragraph spacing */
}

/* No indent for first paragraph after a heading or if it's the very first */
h1 + p,
body > p:first-of-type {
    text-indent: 0;
}

/* Handle paragraphs made of only a non-breaking space */
p:empty, p:contains(' ') { /* Check for empty or only nbsp */
    min-height: 1em;
    text-indent: 0;
}


/* Basic styling for placeholder text */
i {
    color: #777777;
    font-style: italic;
    text-indent: 0; /* No indent for italic placeholders */
    display: block; /* Make italic placeholders block elements */
    text-align: center; /* Center placeholder text */
    margin: 1em 0;
}

/* Ensure images don't overflow */
img, svg {
    max-width: 100%;
    height: auto;
    display: block; /* Avoid extra space below images */
    margin: 1em auto; /* Center block images */
    page-break-inside: avoid; /* Try to keep images on one page */
}
"""

# --- Main Export Function ---

def export_epub(book_root: ET.Element, output_parent_dir: Path, book_title_slug: str, author="Unknown Author", language="en"):
    """Exports the book content to an EPUB file."""
    if epub is None:
        console.print("[bold red]EPUB Export Failed: 'ebooklib' library not found or failed to import.[/bold red]")
        console.print("[bold red]Please install it: pip install EbookLib[/bold red]")
        return False

    if book_root is None:
        console.print("[red]Error: Book data (XML root) is missing, cannot export EPUB.[/red]")
        return False
    if not output_parent_dir.is_dir():
        console.print(f"[red]Error: Output directory '{output_parent_dir}' not found.[/red]")
        return False

    try:
        # 1. Extract Metadata from XML
        title = book_root.findtext("title", book_title_slug.replace('-', ' ').title()) # Use slug as fallback
        # Look for author/language in XML (future enhancement?)
        # xml_author = book_root.findtext("author")
        # if xml_author: author = xml_author
        # xml_lang = book_root.findtext("language")
        # if xml_lang: language = xml_lang

        chapters_sorted = _get_sorted_chapters(book_root)
        if not chapters_sorted:
             console.print(f"[bold red]Error: No chapters found in book data. Cannot generate EPUB.[/bold red]")
             return False

        # 2. Initialize EbookLib Book
        book = epub.EpubBook()
        book_uuid_str = f"urn:uuid:{uuid.uuid4()}"

        # Set core metadata
        book.set_identifier(book_uuid_str)
        book.set_title(title)
        book.set_language(language)
        book.add_author(author) # Add more authors if needed
        # Add optional metadata (modify as needed)
        book.add_metadata('DC', 'publisher', 'PulpGen Publishing')
        book.add_metadata('DC', 'date', datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'))
        book.add_metadata('DC', 'description', book_root.findtext("synopsis", "Novel generated with PulpGen."))

        console.print(Panel(f"Generating EPUB for: [cyan]{title}[/cyan]", style="blue", title="EPUB Export"))
        console.print(f"  Author: [cyan]{author}[/cyan]")
        console.print(f"  Language: [cyan]{language}[/cyan]")
        console.print(f"  UUID: [dim]{book_uuid_str}[/dim]")
        console.print(f"  Chapters Found: {len(chapters_sorted)}")

        # 3. Handle Cover Image (Look for cover.svg or cover.jpg/png)
        cover_item = None
        cover_filename_epub = None
        potential_covers = ["cover.svg", "cover.jpg", "cover.jpeg", "cover.png"]
        found_cover_path = None

        for cover_name in potential_covers:
            cover_path = output_parent_dir / cover_name
            if cover_path.exists():
                found_cover_path = cover_path
                break # Use the first one found

        if found_cover_path:
            try:
                media_types = {'.svg': 'image/svg+xml', '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg', '.png': 'image/png'}
                ext = found_cover_path.suffix.lower()
                media_type = media_types.get(ext)

                if media_type:
                    cover_filename_epub = f"cover{ext}" # Keep extension for internal EPUB name
                    with open(found_cover_path, 'rb') as f:
                        cover_content = f.read()

                    # Create the cover EpubItem
                    cover_item = epub.EpubItem(
                        file_name=cover_filename_epub,
                        media_type=media_type,
                        content=cover_content
                    )
                    book.add_item(cover_item)

                    # Set the cover metadata in OPF
                    # ebooklib handles the necessary properties ('cover-image')
                    book.set_cover(cover_filename_epub, cover_content, create_page=False)
                    console.print(f"  Processed cover image: [cyan]{found_cover_path.name}[/cyan]")
                else:
                    console.print(f"[yellow]Warning: Unsupported cover image format '{ext}'. Skipping.[/yellow]")

            except Exception as e:
                console.print(f"[yellow]Warning: Could not process cover file {found_cover_path.name}: {e}[/yellow]")
                cover_item = None # Ensure it's None if processing failed
        else:
            console.print("[yellow]  Note: No cover image (cover.svg/jpg/png) found in project directory.[/yellow]")

        # 4. Add CSS Stylesheet
        css_filename = "style.css"
        default_css = epub.EpubItem(
            uid="style_default",
            file_name=css_filename,
            media_type="text/css",
            content=DEFAULT_CSS.encode('utf-8') # Use bytes
        )
        book.add_item(default_css)
        console.print("  Added default CSS stylesheet.")

        # 5. Process and Add Chapters
        epub_chapters = [] # Keep track of EpubHtml items for the spine/TOC
        console.print("  Processing chapters...")

        for i, chapter_elem in enumerate(chapters_sorted):
            chap_id = chapter_elem.get("id", f"chap{i+1}")
            chap_num = chapter_elem.findtext("number", chap_id)
            chap_title_raw = chapter_elem.findtext("title", f"Chapter {chap_num}")
            chap_title = f"Chapter {chap_num}: {chap_title_raw}" if not chap_title_raw.lower().startswith("chapter") else chap_title_raw

            # Create a unique filename for the chapter XHTML
            xhtml_filename = f"chapter_{slugify(chap_id)}.xhtml"
            console.print(f"    Adding Chapter {chap_num}: [dim]'{chap_title_raw}'[/dim] as {xhtml_filename}")

            # Create EpubHtml item for the chapter
            chapter_xhtml_item = epub.EpubHtml(
                title=chap_title,       # Full title for TOC
                file_name=xhtml_filename,
                lang=language,
                uid=f"chap_{chap_id}"    # Unique ID for the chapter item
            )
            # Format XML content to XHTML bytes
            chapter_xhtml_item.content = format_chapter_xhtml(chapter_elem, chap_title, css_filename)

            # Link the CSS file to this chapter
            chapter_xhtml_item.add_item(default_css)

            # Add chapter item to the book
            book.add_item(chapter_xhtml_item)
            epub_chapters.append(chapter_xhtml_item) # Add to list for spine/TOC

        # 6. Define Spine (Reading Order)
        # Include 'nav' for EPUB 3 TOC page
        # If a cover page was created (create_page=True), it might need adding too.
        spine_items = ['nav'] + epub_chapters
        # If you want a dedicated title page or other preliminary pages, add them here
        book.spine = spine_items
        console.print("  Defined book spine (reading order).")

        # 7. Create Table of Contents (TOC)
        # TOC links should point to the chapter's file_name
        # The text displayed in the TOC is the chapter's title
        book.toc = [epub.Link(chap.file_name, chap.title, chap.id) for chap in epub_chapters]
        console.print("  Defined Table of Contents (TOC).")

        # 8. Add NCX (legacy TOC for EPUB 2 compatibility) and Nav Document (EPUB 3 TOC/landmarks)
        book.add_item(epub.EpubNcx())
        book.add_item(epub.EpubNav())
        console.print("  Added NCX and Nav HTML TOC files.")

        # 9. Define Output Path
        epub_filename = f"{book_title_slug}.epub"
        output_epub_path = output_parent_dir / epub_filename

        # 10. Write EPUB File
        console.print(f"  Generating EPUB file: [cyan]{output_epub_path.resolve()}[/cyan]")
        # EbookLib options: `{'epub3_pages': False}` might be useful for compatibility
        epub.write_epub(output_epub_path, book, {})

        console.print(Panel(f"[bold green]✓ EPUB generated successfully![/bold green]", style="green", title="EPUB Export Complete"))
        console.print(f"  Saved to: [link=file://{output_epub_path.resolve()}]{output_epub_path.resolve()}[/link]")
        console.print("[yellow]  Recommendation:[/yellow] Validate the generated EPUB using an online validator or a tool like 'epubcheck'.")
        return True

    except FileNotFoundError as fnf_error:
        console.print(f"[bold red]EPUB Export Error: File not found - {fnf_error}[/bold red]")
        return False
    except ET.ParseError as e:
        console.print(f"[bold red]EPUB Export Error: Could not parse book XML data: {e}[/bold red]")
        return False
    except NameError as ne: # Catches if epub failed to import
         if 'epub' in str(ne):
             # Already printed message about missing library earlier
             pass
         else:
             console.print(f"[bold red]EPUB Export Error (NameError): {ne}[/bold red]")
         return False
    except Exception as e:
        console.print(f"[bold red]An unexpected error occurred during EPUB export: {e}[/bold red]")
        console.print_exception(show_locals=False, word_wrap=True)
        return False

# Example of how pulpgen would call this (do not run this directly here)
# if __name__ == '__main__':
#     # This is for testing ONLY - replace with actual pulpgen call
#     print("This script is intended to be imported by pulpgen.py, not run directly.")
#     # Example usage for testing:
#     # test_project_dir = Path("./path/to/your/test-project-folder")
#     # if test_project_dir.exists() and (test_project_dir / "final.xml").exists():
#     #     try:
#     #         test_tree = ET.parse(test_project_dir / "final.xml")
#     #         test_root = test_tree.getroot()
#     #         test_slug = slugify(test_root.findtext("title", "test-book"))
#     #         export_epub(test_root, test_project_dir, test_slug, author="Test Author")
#     #     except Exception as test_e:
#     #         print(f"Test execution failed: {test_e}")
#     # else:
#     #     print(f"Test project folder or final.xml not found at {test_project_dir}")
